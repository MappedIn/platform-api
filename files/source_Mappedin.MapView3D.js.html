<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>source/Mappedin.MapView3D.js - The Mappedin Web SDK</title>
    <meta name="description" content="An easy way to render beautiful 2D or 3D maps on your website, powered by Mappedin">
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="stylesheet" href="../assets/vendor/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="../assets/css/theme.css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,500,600,700' rel='stylesheet' type='text/css'>
    

      <style>
        body a {
          color: #ff5000;
        }
        body a:hover {
          color: #ff5000;
          opacity: 0.5;
        }
        .navbar.navbar-default .navbar-nav> li> a:focus, .navbar.navbar-default .navbar-nav> li> a:hover {
          color: #ff5000;
        }
        .navbar.navbar-default .navbar-nav> .active> a, .navbar.navbar-default .navbar-nav> .active> a:focus, .navbar.navbar-default .navbar-nav> .active> a:hover {
          color: #ff5000;
        }
        #docs-main .page-header {
          color: #ff5000;
        }
        #docs-main .page-section .nav-tabs {
          border-bottom: 1px solid #ff5000;
        }
        #docs-main .page-section .nav-tabs> li.active a {
          background: #ff5000;
          border: 1px solid #ff5000;
        }
        #sidebar li.panel .panel-body ol> li.active, #sidebar li.panel .panel-body ol> li:hover {
          background: #efefef;
        }
      </style>
</head>
<body>
    <nav class="navbar navbar-default">
      <div class="container-fluid">
        <div class="navbar-header">
              <img src="../assets/img/logo.png" alt="default">
            <span>The Mappedin Web SDK</span>
          </a>
        </div>

        <div class="collapse navbar-collapse" id="nav">
          <ul class="nav navbar-nav navbar-right">
            <li><a href="https://github.com/MappedIn/platform-api" class="fa fa-github github"></a></li>
          </ul>
        </div>
      </div>
    </nav>
    <div id="main-wrapper" class="row">
        <div id="content-wrapper">
            <ol class="panel-group" id="sidebar" role="tablist" aria-multiselectable="true">
                <li class="panel panel-default">
                    <div class="panel-heading" role="tab" id="sidebar-search-heading">
                        <h4 class="panel-title">
                      <a role="button" data-toggle="collapse" href="#sidebar-search" aria-expanded="true" aria-controls="collapseOne">
                        Search
                      </a>
                    </h4>
                    </div>
                    <div id="sidebar-search" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="sidebar-search-heading">
                        <div class="panel-body">
                            <div id="api-tabview-filter">
                                <input type="search" id="api-filter" placeholder="Search...">
                            </div>
                        </div>
                    </div>
                </li>
                    <li class="panel panel-default">
                        <div class="panel-heading" role="tab" id="sidebar-version-heading">
                            <h4 class="panel-title">
                                  Version: 1.21.1
                                </a>
                            </h4>
                        </div>
                    </li>
                <li class="panel panel-default">
                    <div class="panel-heading" role="tab" id="sidebar-modules-heading">
                        <h4 class="panel-title">
                    <a role="button" data-toggle="collapse" href="#sidebar-modules" aria-expanded="true" aria-controls="collapseOne">
                      Modules
                    </a>
                  </h4>
                    </div>
                    <div id="sidebar-modules" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="sidebar-modules-heading">
                        <div class="panel-body">
                                <ol>
                                        <li>
                                            <a href="../modules/Mappedin.html">Mappedin</a>
                                        </li>
                                </ol>
                        </div>
                    </div>
                </li>
            
                <li class="panel panel-default">
                    <div class="panel-heading" role="tab" id="sidebar-classes-heading">
                        <h4 class="panel-title">
                      <a role="button" data-toggle="collapse" href="#sidebar-classes" aria-expanded="true" aria-controls="collapseOne">
                        Classes
                      </a>
                    </h4>
                    </div>
                    <div id="sidebar-classes" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="sidebar-classes-heading">
                        <div class="panel-body">
                            <ol>
                                    <li>
                                        <a href="../classes/Analytics.html">Analytics</a>
                                    </li>
                                    <li>
                                        <a href="../classes/CameraControls.html">CameraControls</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Easing.html">Easing</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Mappedin.html">Mappedin</a>
                                    </li>
                                    <li>
                                        <a href="../classes/MappedinCategory.html">MappedinCategory</a>
                                    </li>
                                    <li>
                                        <a href="../classes/MappedinDirections.html">MappedinDirections</a>
                                    </li>
                                    <li>
                                        <a href="../classes/MappedinDirective.html">MappedinDirective</a>
                                    </li>
                                    <li>
                                        <a href="../classes/MappedinEvent.html">MappedinEvent</a>
                                    </li>
                                    <li>
                                        <a href="../classes/MappedinLocation.html">MappedinLocation</a>
                                    </li>
                                    <li>
                                        <a href="../classes/MappedinMap.html">MappedinMap</a>
                                    </li>
                                    <li>
                                        <a href="../classes/MappedinMapGroup.html">MappedinMapGroup</a>
                                    </li>
                                    <li>
                                        <a href="../classes/MappedinNode.html">MappedinNode</a>
                                    </li>
                                    <li>
                                        <a href="../classes/MappedinPolygon.html">MappedinPolygon</a>
                                    </li>
                                    <li>
                                        <a href="../classes/MappedinVenue.html">MappedinVenue</a>
                                    </li>
                                    <li>
                                        <a href="../classes/MappedinVortex.html">MappedinVortex</a>
                                    </li>
                                    <li>
                                        <a href="../classes/MapView.html">MapView</a>
                                    </li>
                                    <li>
                                        <a href="../classes/MapView2D.html">MapView2D</a>
                                    </li>
                                    <li>
                                        <a href="../classes/MapView3D.html">MapView3D</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Marker.html">Marker</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Search.html">Search</a>
                                    </li>
                                    <li>
                                        <a href="../classes/TextLabel.html">TextLabel</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Tween.html">Tween</a>
                                    </li>
                            </ol>
                        </div>
                    </div>
                </li>
            </ol>
            <div class="content-container">
                <div class="apidocs">
                    <div id="docs-main">
                        <div class="content">
<div class="page-header">
    <h1><i class="fa fa-file-code-o" aria-hidden="true"></i>  File</h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
/* global Float32Array Promise */
//var THREE = require(&quot;three&quot;);
import {
	WebGLRenderer,
	Scene,
	PerspectiveCamera,
	Vector2,
	Raycaster,
	Box3,
	Vector3,
	Font,
	Object3D,
	Color,
	CatmullRomCurve3,
	TubeGeometry,
	BufferGeometry,
	BufferAttribute,
	ShaderMaterial,
	Mesh,
	DirectionalLight,
	HemisphereLight,
	BoxGeometry,
	MeshBasicMaterial,
} from &#x27;three&#x27;;

import p2 from &#x27;p2&#x27;;
import unique from &#x27;array-unique&#x27;;

import TWEEN from &#x27;@tweenjs/tween.js&#x27;;
import &#x27;./object3D.destroy&#x27;;

import CameraControls from &#x27;./Mappedin.CameraControls.js&#x27;;
import MapView from &#x27;./Mappedin.MapView.js&#x27;;
import HoverLabel from &#x27;./Mappedin.HoverLabel.js&#x27;;
import VertexShader from &#x27;./Mappedin.Shaders.VertexShader.glsl&#x27;;
import FragmentShader from &#x27;./Mappedin.Shaders.FragmentShader.glsl&#x27;;
import Marker from &#x27;./Mappedin.MapView3D.Marker.js&#x27;;
import PubSub from &#x27;./Mappedin.PubSub.js&#x27;;
import { scrubMaterial, getObject, getObjectId } from &#x27;./utils&#x27;;
import TextLabel from &#x27;./Mappedin.TextLabel&#x27;;
import MapManager from &#x27;./Mappedin.MapManager&#x27;;

var Shaders =  {};
var Mappedin = {};

Mappedin.MapView = MapView;
Mappedin.HoverLabel = HoverLabel;

Mappedin.CameraControls = CameraControls;

Shaders.VertexShader = VertexShader;
Shaders.FragmentShader = FragmentShader;

var DEFAULT_FONT_JSON = require(&quot;./externals/Droid_Sans_Regular.json&quot;);

/**
* A 3D version MapView. Requires WebGL to run, and supports full camera pan/tilt/rotation.
*
* @class MapView3D
* @extends MapView
* @constructor
* @param container {Div} The div to place the MapView in.
* @param venue {Venue} The results from the Mappedin API that powers this MapView.
* @param options {Object} Some options the MapView can use.
* @param [options.alpha=false] {Boolean} True if the &#x60;opacity&#x60; argument to &#x60;setBackgroundColor&#x60; should be considered.
	@param [options.antialias=true] {Boolean} Controls whether antialiasing is on. Defaults to true, as long as devicePixelRatio is 1. This is very expensive on high resolution screens.
	@param [options.backgroundColor] {Number} Sets the initial background color of the map, including while loading.
	@param [options.backgroundAlpha] {Number} The opacity of the initial background color.
	@param [options.onDataLoaded] {Function} A callback executed with the 3D files have been downloaded for the first Map, and are starting to load into memory. The MapView is fully functional at this point, but some things will still be popping in.
	@param [options.onFirstMapLoaded] {Function} A callback executed when the first map is fully loaded. This means onDataLoaded has already been fired (if specified) and then all the textures and other resources have finished popping in.
	@param [options.disableHover=false] {Boolean} If you would like to completely disable the hover effect (if you are on a touch screen for example), set this to true.
	@param [options.firstMap] {MappedinMap} If you don&#x27;t want to load the default Map first, set the Map you want to load first here. Useful for deep linking to a certain floor/location. Since you won&#x27;t have the Map object/ID until you get the {{#crossLink &quot;MappedinVenue&quot;}}{{/crossLink}} data, there is a callback you can set on Mappedin.{{#crossLink &quot;Mapppedin/initialize:method&quot;}}{{/crossLink}} to fill this in.
*/
var MapView3D = function(container, venue, options) {
	var scope = this;
	Object.assign(this, PubSub.prototype);
	Mappedin.MapView.call(this, container, venue, options);
	this.type = &quot;MapView3D&quot;;

	var hasTouched = false; // Track the user has ever had a touch event fire, to handle turning off hover effects for iOS
	var contextLost = false;
	var antialias = false;
	var disableHover = false;
	var disableZoomOnMapSizeChange = false;
	var backgroundColor = 0xffffff;
	var backgroundAlpha = 1;
	let markerWorldIslandSplit;
	if (options) {
		if (options.antialias == &quot;ON&quot;) {
			antialias == true;
		} else if (options.antialias == &quot;OFF&quot;) {
			antialias = false;
		} else {
			antialias = window.devicePixelRatio &lt;= 1.0;
		}

		if (typeof options.markerWorldIslandSplit !== &#x27;undefined&#x27;) {
			markerWorldIslandSplit = options.markerWorldIslandSplit;
		} else {
			markerWorldIslandSplit = true;
		}

		if (options.disableHover) {
			disableHover = true;
		}

		if (options.disableZoomOnMapSizeChange) {
			disableZoomOnMapSizeChange = true;
		}

		if (options.backgroundColor) {
			backgroundColor = options.backgroundColor;
		}

		if (options.backgroundAlpha) {
			backgroundAlpha = options.backgroundAlpha;
		}
	}

	var shouldConsiderAlpha = options.alpha === true;

	var renderer;

	try {
		renderer = new WebGLRenderer({
			alpha: shouldConsiderAlpha,
			&quot;antialias&quot;: antialias // Turn off antialiasing on HDPI displays
		});
	} catch (e) {
		if (options.onWebGLRendererError) {
			options.onWebGLRendererError(e);
		}
		return;
	}

	function reportWebGlContextCreationError(e) {
		if (options.onWebGLContextCreationError) {
			options.onWebGLContextCreationError(e);
		}
	}

	function reportWebGlContextLost(e) {
		e.preventDefault();
		if (options.onWebGLContextLost) {
			options.onWebGLContextLost(e);
		}
		contextLost = true;
	}

	function onWebGLContextRestored() {
		if (options.onWebGLContextRestored) {
			options.onWebGLContextRestored();
		}
		contextLost = false;
	}

	renderer.domElement.addEventListener(&#x27;webglcontextcreationerror&#x27;, reportWebGlContextCreationError);
	renderer.domElement.addEventListener(&#x27;webglcontextlost&#x27;, reportWebGlContextLost);
	renderer.domElement.addEventListener(&#x27;webglcontextrestored&#x27;, onWebGLContextRestored);

	var lastHover = null;

	// Currently highlighted polygons
	var highlightedPolygons = {};

	// Our 3D scene
	this.scene = new Scene();

	// Scale the renderer for HDPI displays
	this.resolutionScale = window.devicePixelRatio;

	// The camera object has two other objects that act as joints. Camera orbit is what handles panning and rotation
	// cameraElevation is what controls the angle of the camera off the ground, and zoom is the distance between the camera and cameraElevation.
	// This makes it trivial to anchor the camera&#x27;s pan motion to the map plane.
	var cameraObject = new PerspectiveCamera(40, this.container.clientWidth / this.container.clientHeight, 50, 100000);
	var cameraElevation = new Object3D();
	cameraElevation.add(cameraObject);

	var cameraOrbit = new Object3D();
	cameraOrbit.add(cameraElevation);

	this.scene.add(cameraOrbit);

	cameraObject.updateProjectionMatrix();
	cameraObject.updateMatrixWorld(true);

	// Change this factor to influence how much the camera zooms in on a focusOn call
	this.focusZoomFactor = 1.1;

	// Track if camera is rotating to see if we need to flip labels
	var rotating = false;

	function cameraRotationStarted() {
		rotating = true;
		flippablesNeedUpdating = true;
	}

	function cameraRotationStopped() {
		rotating = false;
		flippablesNeedUpdating = true;
	}

	// Controls whether a mouse down and mouse up are treated as a &quot;click&quot; or not, so you don&#x27;t always click while panning
	var MOUSE_CLICK_TIME_THRESHOLD = 300;
	var MOUSE_CLICK_DISTANCE_THRESHOLD = 30;
	var mouseDownStart = {time: 0, clientc: 0, clienty: 0};

	/// Markers ///
	var markerWorld = new p2.World({
		applyGravity: false,
		emitImpactEvent: false,
		islandSplit: markerWorldIslandSplit,
		solver: new p2.GSSolver()
	});

	var onCollisionStart = function (event) {
		event.bodyA._mNumCollisions++;
		event.bodyB._mNumCollisions++;
	};

	var onCollisionEnd = function (event) {
		event.bodyA._mNumCollisions--;
		event.bodyB._mNumCollisions--;
	};

	markerWorld.on(&quot;beginContact&quot;, onCollisionStart);
	markerWorld.on(&quot;endContact&quot;, onCollisionEnd);

	// Controls whether markers should disapear when the camera is moving
	var hideMarkersOnCameraMove = false;

	// Controls how much extra to run the physics engine by, to keep markers locked on target when needed
	var physicsResolution = 0.1;
	var physicsTime = 1.0;

	var rotateWithCamera = [];

	// Rotate the logos to align with the camera the first time
	var flippablesNeedUpdating = true;

	/// Paths ///
	// Tracks current path segments for deletion later
	var pathSegments = {};

	// A table of the THREE Meshes that you can retrieve by PolygonId
	var polygonMeshesById = {};

	// A table of TextLabel objects by their associated PolygonId
	var textLabelsByPolygonId = {};

	// A list of polygons that are &quot;interactive&quot;, meaning they can be tapped/hovered.
	// The client needs to figure this out using it&#x27;s own logic, but you can use all polygons owned by a location.
	// You could also do all polygons that have entrance nodes, which would let you interact with &quot;empty&quot; polygons.
	var interactivePolygons = {};

	const textMaterials = {};

	const mapManager = new MapManager(polygonMeshesById, markerWorld, renderer, scope);
	this.scene.add(mapManager.object);

	const mapObjects = mapManager.mapObjects;

	Object.defineProperty(this, &#x27;currentMap&#x27;, {
		get() {
			if (mapManager.currentMap) {
				return mapManager.currentMap.id;
			} else if (mapManager.mapObjects.size &gt; 0) {
				return Array.from(mapManager.mapObjects)[0].id;
			} else {
				console.error(&#x27;No maps loaded.&#x27;);
				return null;
			}
		}
	});

	// Current mouse coordinates in Three
	var mouse = new Vector2();
	var cursorPos; // Screen space cursor
	var raycaster = new Raycaster();

	// The label that can hover by the mouse cursor over labeled polygons
	var hoverLabel = new Mappedin.HoverLabel(container);

	// Set up the render command queue to spread expensive operations over multiple frames, to keep the scene from freezing.
	// Currently we only use this to pop text labels in
	//var renderCommandQueue = []

	var MAX_TIME_PER_FRAME = 32;
	var nextFrameTime = Date.now() + MAX_TIME_PER_FRAME;

	//** Convenience functions to let our public methods handle either Mappedinjs objects or IDs **//

	// Turns a polygon or id into a polygon, so our functions can take either
	var getPolygon = function (polygon) {
		return getObject(polygon, venue.polygons);
	};

	// Makes the MapView display the map that has the corrisponding mapId
	this.setMap = mapManager.setMap;
	this.expandMaps = mapManager.expandMaps;
	this.contractMaps = mapManager.contractMaps;

	Object.defineProperty(this, &#x27;mapsExpanded&#x27;, {
		get() {
			return mapManager.expanded;
		}
	});

	this.expandMaps = mapManager.expandMaps;
	this.contractMaps = mapManager.contractMaps;

	this.showEntireMap = function(options) {
		if (!options) options = {};

		var polygons;
		if (options.interactiveOnly) {
			polygons = Object.keys(interactivePolygons);
		} else {
			var mapObject = mapObjects.get(scope.currentMap);

			polygons = mapObject.object.children.map(function(mesh) {
				return mesh.name;
			});
		}

		options.polygons = polygons;

		return this.focusOn(options);
	};

	// Resets the pan bounds to fit the current map
	this.resetPanBounds = function() {
		var mapObject = mapObjects.get(scope.currentMap);
		scope.controls.panBounds.min = scope.controls.getPosition();
		scope.controls.panBounds.max = scope.controls.getPosition();

		var box = mapObject.boundingBox;
		if (!box) {
			var box3 = new Box3();
			box = box3.setFromObject(mapObject.object);
			mapObjects.get(scope.currentMap).boundingBox = box;
		}
		mapManager.expandPanBounds(box);
	};

	this.addMap = mapManager.addMap;

	this.removeMap = mapManager.removeMap;

	this.removeAllMaps = mapManager.removeAllMaps;

	/// Mouse events ///
	function clearMouse() {
		mouse.x = Infinity;
		mouse.y = Infinity;
	}

	function getMousePos(event) {
		var rect = container.getBoundingClientRect();
		return {
			x: (event.clientX - rect.left) / (rect.right - rect.left) * canvasWidth,
			y: (event.clientY - rect.top) / (rect.bottom - rect.top) * canvasHeight
		};
	}

	var calculateMouseCoordinates = function(event) {
		cursorPos = getMousePos(event);
		mouse.x = (cursorPos.x / canvasWidth) * 2 - 1;
		mouse.y = - (cursorPos.y / canvasHeight) * 2 + 1;
	};

	// Update the mouse and render for the hover effect.
	var onMouseMove = function(event) {
		event.preventDefault();
		calculateMouseCoordinates(event);
		// If your device doesn&#x27;t support pointerType (like Safari) you can never get the hover back once you&#x27;ve touched the screen
		// Since Apple doesn&#x27;t have touch capable Macbooks, that&#x27;s probably fine.
		// Mixed devices like Surface Book should respond with the input you are currently using
		if (event.pointerType != &quot;touch&quot; || (event.pointerType == undefined &amp;&amp; hasTouched)) {
			doHoverEffect();
			hoverLabel.setPosition(cursorPos.x, cursorPos.y);
		}
	};

	// Keep track of when the mouse event starts so we can detect our own click onMouseUp
	var onMouseDown = function(event) {
		mouseDownStart = {time: Date.now(), clientX: event.clientX, clientY: event.clientY};
		incrementTouches(event);
	};

	var onTouchStart = function(event) {
		hasTouched = true;
		if (event.touches.length == 1) {
			onMouseDown(event.touches[0]);
		} else {
			mouseDownStart = 0;
		}
	};

	// Fire a click event if the event happens fast enough, and the mouse doesn&#x27;t move very far, so we don&#x27;t get a false positive on panning
	var onMouseUp = function(event) {
		if (event.target.parentNode != container) {
			return;
		}
		var distance = Math.sqrt(Math.pow(event.clientX - mouseDownStart.clientX, 2) + Math.pow(event.clientY - mouseDownStart.clientY, 2));
		if ((Date.now() &lt; mouseDownStart.time + MOUSE_CLICK_TIME_THRESHOLD) &amp;&amp; distance &lt;= MOUSE_CLICK_DISTANCE_THRESHOLD) {
			calculateMouseCoordinates(event);

			var polygons = detectPolygonsUnderMouse();

			//scope.clearAllPolygonColors()
			for (var i = 0, iLen = polygons.length; i &lt; iLen; ++i) {
				var polygon = polygons[i];
				if (interactivePolygons[polygon]) {
					if (!scope.onPolygonClicked(polygon)) {
						return;
					}
				}
			}
			// If the event is never consumed, or we don&#x27;t hit any interactive polygons, fire
			// onNothingClicked to allow the developer to clean up the map state
			scope.onNothingClicked();
		} else {
			decrementTouches(event);
			if (!(scope.touchCount)) {
				scope.publish(scope.currentInteractionEvent);
				this.currentInteractionEvent = &#x27;&#x27;;
			}
		}
	};

	var incrementTouches = function(event) {
		if (window.PointerEvent &amp;&amp; event.pointerType == &#x27;touch&#x27;) {
			scope.touchCount = (scope.touchCount || 0) + 1;
		}
	};

	var decrementTouches = function(event) {
		if (window.PointerEvent &amp;&amp; event.pointerType == &#x27;touch&#x27;) {
			scope.touchCount = scope.touchCount - 1;
		}
	};

	var onTouchEnd = function (event) {
		event.preventDefault();
		onMouseUp(event.changedTouches[0]);
	};

	// Updates the size of the renderer and where everything is when the window is resized
	var onWindowResize = function() {
		scope.tryRendering();
	};

	// Moves the camera to focus in on a specific polygon
	this.focusOnPolygon = function (polygon, changeZoom, duration, curve) {
		return scope.focusOn({
			polygons: [polygon],
			changeZoom: changeZoom,
			duration: duration,
			curve: curve
		});
	};

	// Moves the camera to focus on an entire path and optionally it&#x27;s starting and ending polygon
	this.focusOnPath = function (path, polygons, changeZoom, duration, curve) {
		return scope.focusOn({
			nodes: path,
			polygons: polygons,
			changeZoom: changeZoom,
			duration: duration,
			curve: curve
		});
	};

	let debugObj;

	// The most flexible way to focus
	this.focusOn = function (options) {
		if (options == null) { return; }
		var changeZoom = options.changeZoom !== undefined ? options.changeZoom : true;
		var duration = options.duration || 200;
		var focusZoomFactor = options.focusZoomFactor || scope.focusZoomFactor;
		var curve = options.curve;
		var horizontalFovFactor = options.horizontalFovFactor || 1;
		var verticalFovFactor = options.verticalFovFactor || 1;
		var callback = options.callback;
		var minZoom = options.minZoom !== undefined ? options.minZoom : scope.controls.minZoom;
		var updateZoomLimits = options.updateZoomLimits || true;

		var targetOnMap = false;

		var pointCloud = [];

		if (options.nodes) {
			var nodes = options.nodes;
			for (var i = 0, iLen = nodes.length; i &lt; iLen; i++) {
				var nodeObject = nodes[i];
				if (typeof nodeObject === &quot;string&quot;) {
					nodeObject = getObject(nodeObject, venue.nodes);
				}
				if (nodeObject.map == undefined || nodeObject.map == scope.currentMap) {
					pointCloud.push(scope.convertTo3DMapPosition(nodeObject));
					targetOnMap = true;
				}
			}
		}

		// debug/convenince functions
		if (options.debug) {
			if (debugObj != null) {
				debugObj = new Object3D();
			} else {
				debugObj.destroy();
			}
			scope.scene.add(debugObj);
			var geometry = new BoxGeometry(100, 100, 100);
			var material = new MeshBasicMaterial({ color: 0x00ff00 });
		}

		if (options.points) {
			options.points.forEach(pt =&gt; pointCloud.push(pt));
			targetOnMap = true;
		}

		// this will ensure contents of a 3D bounding box fit in the view
		if (options.boundingBox) {
			const { min, max } = options.boundingBox;
			const points = [
				new Vector3(min.x, min.y, min.z),
				new Vector3(min.x, max.y, min.z),
				new Vector3(max.x, min.y, min.z),
				new Vector3(max.x, max.y, min.z),
				new Vector3(min.x, min.y, max.z),
				new Vector3(min.x, max.y, max.z),
				new Vector3(max.x, min.y, max.z),
				new Vector3(max.x, max.y, max.z)
			];
			points.forEach((pt) =&gt; {
				if (options.debug) {
					var cube = new Mesh(geometry, material);
					cube.position.set(pt.x, pt.y, pt.z);
					debugObj.add(cube);
				}
				pointCloud.push(pt);
			});
			targetOnMap = true;
		}

		if (options.polygons) {
			var polygons = options.polygons;
			for (i = 0, iLen = polygons.length; i &lt; iLen; i++) {
				var polygonId = getObjectId(polygons[i]);
				var target = mapObjects.get(scope.currentMap).objectsDictionary[polygonId];
				if (target) {
					var vertexes = 	target.geometry.attributes.position;
					// Should figure out if there&#x27;s a way we can eliminate some of these
					for (var j = 0, jLen = vertexes.count; j &lt; jLen; j++) {
						var vector = new Vector3();
						vector.set(vertexes.getX(j), vertexes.getY(j), vertexes.getZ(j));
						pointCloud.push(vector);
					}
					targetOnMap = true;
				}
			}
		}

		if (targetOnMap) {
			scope.tryRendering();
			var frame = getCameraFrameForPoints(
				pointCloud,
				horizontalFovFactor,
				verticalFovFactor,
				options.padding || this.cachedPadding,
				true
			);
			var zoomToReduceTo = scope.getZoomLevelForCurrentMap();
			var zoomToExpandTo = frame.zoom;
			if (updateZoomLimits) {
				scope.controls.restrictZoomLimits(zoomToReduceTo);
				scope.controls.expandZoomLimits(zoomToExpandTo * focusZoomFactor);
			}
			var cameraSettings = {position: frame.position};
			if (changeZoom) {
				cameraSettings.zoom = Math.max(frame.zoom * focusZoomFactor, minZoom);
			}
			return scope.controls.animateCamera(cameraSettings, duration, curve, callback);
		} else {
			return scope.controls.animateCamera({}, duration, curve, callback);
		}
	};

	this.CAMERA_FRAME_PADDING_SIDES = [&#x27;top&#x27;, &#x27;bottom&#x27;, &#x27;left&#x27;, &#x27;right&#x27;];
	this.CAMERA_FRAME_PADDING_UNITS = { PIXELS: &#x27;pixels&#x27;, PORTIONS: &#x27;portions&#x27; };

	var getCameraFrameForPoints = function (pointCloud, horizontalFovFactor, verticalFovFactor, padding, ignoreZoom) {
		if (!verticalFovFactor || isNaN(verticalFovFactor)) {
			verticalFovFactor = 1.0;
		}
		if (!horizontalFovFactor || isNaN(horizontalFovFactor)) {
			horizontalFovFactor = 1.0;
		}
		var results = {
			position: scope.controls.getPosition(),
			zoom: scope.controls.minZoom
		};
		if (pointCloud == undefined || pointCloud.length == 0) {
			return results;
		}

		if (!padding) {
			padding = { top: 0, bottom: 0, left: 0, right: 0, type: scope.CAMERA_FRAME_PADDING_UNITS.PIXELS };
		}

		for (var side in scope.CAMERA_FRAME_PADDING_SIDES) {
			if (typeof padding[scope.CAMERA_FRAME_PADDING_SIDES[side]] !== &#x27;number&#x27;) {
				padding[scope.CAMERA_FRAME_PADDING_SIDES[side]] = 0;
			}
		}

		if (!padding.type) {
			padding.type = scope.CAMERA_FRAME_PADDING_UNITS.PIXELS;
		}

		if (padding.type === scope.CAMERA_FRAME_PADDING_UNITS.PORTIONS) {
			padding = {
				top: padding.top * canvasHeight,
				bottom: padding.bottom * canvasHeight,
				left: padding.left * canvasWidth,
				right: padding.right * canvasWidth,
				type: scope.CAMERA_FRAME_PADDING_UNITS.PIXELS
			};
		}
		if (padding.left + padding.right &gt;= canvasWidth || padding.top + padding.bottom &gt;= canvasHeight) {
			return results;
		}

		cameraOrbit.updateMatrixWorld();
		var camMatrix = cameraObject.matrixWorldInverse;

		var yFov = ((cameraObject.fov * (Math.PI / 180)) / 2) * verticalFovFactor;

		var xFov = (Math.atan(Math.tan((cameraObject.fov * (Math.PI / 180)) / 2) * (canvasWidth / canvasHeight))) * horizontalFovFactor;

		if (pointCloud.length == 1) {
			// Keep current zoom; center target in allowed area
			var cameraSpacePoint = pointCloud[0].clone();
			cameraSpacePoint.applyMatrix4(camMatrix);
			var currentBoundsWidth = scope.controls.minZoom * Math.tan(xFov) * 2;
			var currentBoundsHeight = scope.controls.minZoom * Math.tan(yFov) * 2;
			var offsetX = ((padding.left - padding.right) / 2) / canvasWidth;
			var offsetY = ((padding.top - padding.bottom) / 2) / canvasHeight;
			var offsetVector = new Vector3(
				-offsetX * currentBoundsWidth,
				offsetY * currentBoundsHeight,
				0
			);
			cameraSpacePoint.add(offsetVector);
			cameraSpacePoint.applyMatrix4(cameraObject.matrixWorld);
			results.position.x = cameraSpacePoint.x;
			results.position.y = cameraSpacePoint.y;
			return results;
		}


		var min = new Vector3(Infinity, Infinity, Infinity);
		var max = new Vector3(-Infinity, -Infinity, -Infinity);

		var point;
		for (var i = 0, iLen = pointCloud.length; i &lt; iLen; i++) {
			point = pointCloud[i];
			point.applyMatrix4(camMatrix);
			min.min(point);
			max.max(point);
		}

		var originalBoundsWidth = max.x - min.x;
		var originalBoundsHeight = max.y - min.y;

		var containmentWidth = canvasWidth - padding.left - padding.right;
		var containmentHeight = canvasHeight - padding.top - padding.bottom;

		var originalBoundsCenterX = (max.x + min.x) / 2;
		var originalBoundsCenterY = (max.y + min.y) / 2;

		var widthRatio = originalBoundsWidth / containmentWidth;
		var heightRatio = originalBoundsHeight / containmentHeight;

		var minZoomDistance = scope.controls.getZoomScaledMin();
		var maxZoomDistance = scope.controls.getZoomScaledMax();

		var minBoundsWidth = minZoomDistance * Math.tan(xFov) * 2;
		var maxBoundsWidth = maxZoomDistance * Math.tan(xFov) * 2;
		var minimumScaleRatio = minBoundsWidth / canvasWidth;
		var maximumScaleRatio = maxBoundsWidth / canvasWidth;

		var scaleRatio = Math.max(widthRatio, heightRatio);

		if (!ignoreZoom) {
			scaleRatio = Math.min(Math.max(scaleRatio, minimumScaleRatio), maximumScaleRatio);
		}

		var paddedBoundsWidth = containmentWidth * scaleRatio;
		var paddedBoundsHeight = containmentHeight * scaleRatio;

		var boundsForScreen = {
			min: {
				x: originalBoundsCenterX - paddedBoundsWidth / 2 - padding.left * scaleRatio,
				y: originalBoundsCenterY - paddedBoundsHeight / 2 - padding.bottom * scaleRatio
			},
			max: {
				x: originalBoundsCenterX + paddedBoundsWidth / 2 + padding.right * scaleRatio,
				y: originalBoundsCenterY + paddedBoundsHeight / 2 + padding.top * scaleRatio
			}
		};

		var centerX = (boundsForScreen.min.x + boundsForScreen.max.x) / 2;
		var centerY = (boundsForScreen.min.y + boundsForScreen.max.y) / 2;

		var deltaX = Math.abs(centerX - boundsForScreen.min.x);
		var deltaY = Math.abs(centerY - boundsForScreen.min.y);

		var distanceX = deltaX / Math.tan(xFov);
		var distanceY = deltaY / Math.tan(yFov);

		var cameraTarget = new Vector3();
		cameraTarget.set(centerX, centerY, max.z + Math.max(distanceX, distanceY));
		cameraTarget.applyMatrix4(cameraObject.matrixWorld);

		var cameraAnchor = new Vector3();
		cameraAnchor.set(centerX, centerY, max.z);
		cameraAnchor.applyMatrix4(cameraObject.matrixWorld);

		cameraAnchor.sub(cameraTarget);

		var t = cameraTarget.z / cameraAnchor.z;
		results.position.x = cameraTarget.x - (cameraAnchor.x * t);
		results.position.y = cameraTarget.y - (cameraAnchor.y * t);

		cameraAnchor.set(results.position.x, results.position.y, 0);
		cameraTarget.sub(cameraAnchor);

		results.zoom = cameraTarget.length();

		return results;
	};

	this.setPadding = function(padding) {
		this.cachedPadding = padding;
	};

	// Returns the value you should call setZoom on to fit the polygon exactly.
	this.getZoomLevelForPolygon = function(polygon) {
		var polygonId = getObjectId(polygon);
		var pointCloud = [];
		var target = mapObjects.get(scope.currentMap).objectsDictionary[polygonId];
		if (target) {
			var vertexes = target.geometry.attributes.position;
			// Should figure out if there&#x27;s a way we can eliminate some of these
			for (var j = 0, jLen = vertexes.count; j &lt; jLen; j++) {
				var vector = new Vector3();
				vector.set(vertexes.getX(j), vertexes.getY(j), vertexes.getZ(j));
				pointCloud.push(vector);
			}
			return getCameraFrameForPoints(pointCloud, 1, 1, this.cachedPadding, true).zoom;
		}
		return scope.controls.getZoom();
	};

	// Returns the zoom level that will encompass the entire map, with optional padding
	this.getZoomLevelForCurrentMap = function() {
		var target = mapObjects.get(scope.currentMap).object;
		if (target) {
			var box = mapObjects.get(scope.currentMap).boundingBox;
			if (!box) {
				var box3 = new Box3();
				box = box3.setFromObject(target);
				mapObjects.get(scope.currentMap).boundingBox = box;
			}
			var pointCloud = [box.min.clone(), box.max.clone()];

			return getCameraFrameForPoints(pointCloud, 1, 1, this.cachedPadding, true).zoom;
		}
		return scope.controls.getZoom();
	};

	this.getZoomLevelForObject = function(object) {
		var box;
		if (!box) {
			var box3 = new Box3();
			box = box3.setFromObject(object);
		}
		const pointCloud = [box.min.clone(), box.max.clone()];

		return getCameraFrameForPoints(pointCloud, 1, 1, 0, true).zoom;
	};

	// Returns the camera to it&#x27;s default settings
	this.resetCamera = function() {
		var position = {x: 0, y: 0};
		var zoom = scope.getZoomLevelForCurrentMap();
		scope.controls.expandZoomLimits(zoom);
		var tilt = 0.6;
		var rotation = 0;

		scope.controls.setMulti(position, zoom, rotation, tilt);
	};

	// Returns the ratio between map units and metres for the current map
	this.getMapScale = function() {
		return mapObjects.get(scope.currentMap).getMapScale();
	};

	// Returns the angle that points to north, in radians, from the default orientation, for the current map
	this.getNorth = function() {
		return mapObjects.get(scope.currentMap).getNorth();
	};

	this.getPositionLatLon = function(lat, lon, map) {
		if (map == undefined) {
			map = scope.currentMap;
		} else {
			map = getObjectId(map);
		}

		var mapObj = mapObjects.get(map);
		if (mapObj == undefined) {
			throw new Error(&quot;Invalid map: &quot; + map);
		}

		return mapObj.getPositionLatLon(lat, lon);
	};

	// Rotaes a DOM node for you
	var rotateNode = function(element, rotation) {
		element.style.transform = &quot;rotate(&quot; + (rotation + element._mRotationOffset) + &quot;rad)&quot;;
	};

	// Locks a dom node to facing north (or north + some offset). When the camera rotaes, the element will rotate with it
	this.lockNorth = function(element, offset = 0) {
		rotateWithCamera.push(element);
		element._mRotationOffset = offset;
		rotateNode(element, scope.getNorth() + scope.controls.getRotation());
	};

	// Stops the element from rotating to face North with the camera. Doesn&#x27;t reset the rotation
	this.unlockNorth = function(element) {
		delete element._mRotationOffset;
		rotateWithCamera = rotateWithCamera.filter(function (item) {
			return item != element;
		});
	};

	// Internal function to try setting the color of a polygon later, once the map it&#x27;s on has loaded
	var setPolygonColorLater = function (polygonObject, color, textLabelColor) {
		mapObjects.get(polygonObject.map).load().then(function () {
			scope.setPolygonColor(polygonObject, color, textLabelColor);
		});
	};

	// Given a polygon Id, set it to a specific color. If there is a textLabel associated with the polygon, it&#x27;s color will also be set unless you pass -1.
	this.setPolygonColor = function(polygon, color, textLabelColor) {
		var polygonId = getObjectId(polygon);
		var polygonMesh = polygonMeshesById[polygonId];
		if (polygonMesh === undefined) {
			// Set the color later if the polygon isn&#x27;t available at run time
			// If you set the color again after this it will just add it to the pile, so you may see a bit of color cycling when the map first loads if you did A LOT
			var polygonObject = getPolygon(polygon);

			if (polygonObject != undefined &amp;&amp; polygonObject.map != null &amp;&amp; mapObjects.get(polygonObject.map).object == null) {
				setPolygonColorLater(polygonObject, color, textLabelColor);
				return;
			} else {
				// Bad polygon data
				console.error(&quot;Cannot set color of polygon &quot; + polygonId + &quot;, could be bad polygon or data mismatch.&quot;);
				return;
			}
		}

		if (!polygonMesh._MIOriginalMaterial) {
			polygonMesh._MIOriginalMaterial = polygonMesh.material.clone();
		}

		highlightedPolygons[polygonId] = polygonId;

		polygonMesh.material.color.set(color || scope.colors.select || 0x4ca1fc);

		if (textLabelsByPolygonId[polygonId] &amp;&amp; !(textLabelColor &lt; 0)) {
			textLabelsByPolygonId[polygonId].setColor(textLabelColor || scope.colors.textSelect || 0xFFFFFF);
		}
		scope.tryRendering();
	};

	// Resets a polygon back to it&#x27;s original color
	// If the user is hovering over a polygon, it will still have the hover effect.
	this.clearPolygonColor = function(polygon) {
		var polygonId = getObjectId(polygon);
		var polygonMesh = polygonMeshesById[polygonId];
		if (!polygonMesh) return;

		if (polygonMesh._MIOriginalMaterial) {
			scrubMaterial(polygonMesh.material);
			polygonMesh.material = polygonMesh._MIOriginalMaterial.clone();
			scrubMaterial(polygonMesh._MIOriginalMaterial);
			polygonMesh._MIOriginalMaterial = undefined;
		}
		delete highlightedPolygons[polygonId];
		if (textLabelsByPolygonId[polygonId]) {
			textLabelsByPolygonId[polygonId].clearColor();
		}
		scope.tryRendering();
	};

	// Resets all polygons back to their original colors
	this.clearAllPolygonColors = function() {
		var ids = Object.keys(highlightedPolygons);
		for (var i = 0, iLen = ids.length; i &lt; iLen; ++i) {
			var id = ids[i];
			scope.clearPolygonColor(highlightedPolygons[id]);
		}
		highlightedPolygons = {};
		scope.tryRendering();
		// Temporary solution until https://github.com/mrdoob/three.js/issues/12447 is addressed
		renderer.renderLists.dispose();
	};

	// Detects the interactive polygons currently under the mouse
	var detectPolygonsUnderMouse = function() {
		raycaster.setFromCamera(mouse, cameraObject);
		var intersects = raycaster.intersectObjects(scope.scene.children, true)
			.map(function(obj) {
				return obj.object.name;
			});
		unique(intersects);
		var polygons = [];
		for (var i = 0, iLen = intersects.length; i &lt; iLen; ++i) {
			var name = intersects[i];
			if (name &amp;&amp; interactivePolygons[name]) { // Doesn&#x27;t actually guaruntee it&#x27;s a Mappedin Polygon, but that&#x27;s the closest we can get without knowing about the Polygon data
				polygons.push(name);
			}
		}
		return polygons;
	};

	// Makes a polygon hoverable/clickable
	this.addInteractivePolygon = function (polygon) {
		var polygonId = getObjectId(polygon);
		interactivePolygons[polygonId] = true;
	};

	// Makes a polygon no longer hoverable/clickable
	this.removeInteractivePolygon = function (polygon) {
		var polygonId = getObjectId(polygon);
		delete interactivePolygons[polygonId];
	};


	// This is called when an unhighlighted interactive polygon is moused over
	// It just applies the highlight effect.
	// You can change the hover color on mapView.colors.hover
	var onPolygonHoverOver = function(polygon) {
		var polygonId = getObjectId(polygon);
		var polygonMesh = polygonMeshesById[polygonId];
		if (!polygonMesh) {
			return;
		}

		scope.setPolygonColor(polygonId, scope.colors.hover, -1);
		return false;
	};

	// This is called when the mouse leaves a polygon that had the hover effect
	// It removes the highlight and sets the polygon back to it&#x27;s original color.
	var onPolygonHoverOut = function(polygonId) {
		var polygon = polygonMeshesById[polygonId];
		if (!polygon || polygon.material.color.getHex() != scope.colors.hover) {
			return;
		}

		scope.clearPolygonColor(polygonId);
		return false;
	};

	// This creates a div with whatever HTML you provide, anchors it to position in 3D space, and optionally applies a css class you provide.
	// Position should be something you got from getPositionPolygon, getPositionNode, or convertTo3DMapPosition.
	// The marker is added for you. You will need to manage map changes yourself.
	this.createMarker = function(html, position, className, map) {
		var marker = new MapView3D.Marker(scope, {
			html: html,
			position: position,
			className: className,
			map
		});

		if (map &amp;&amp; map.id) {
			const mapObject = mapObjects.get(map.id);
			marker.setPosition(marker._mOriginalPosition.clone().add(mapObject.object.position));
		}

		scope.addMarker(marker);
		scope.tryRendering();

		return marker;
	};

	this.addMarker = function (marker) {
		scope.container.appendChild(marker.div);
		if (marker._mPosition &amp;&amp; marker._mAnchor == undefined) {
			var projection = marker._mPosition.clone().project(cameraObject);

			var x = (projection.x + 1)  / 2 * canvasWidth;
			var y = (-projection.y + 1) / 2 * canvasHeight;

			if (isNaN(x) || isNaN(y)) {
				x = 0;
				y = 0;
			}

			// Should skip this if phyics is off? Also not needed in 2D. Maybe move this to MapView
			var anchor = new p2.Body({
				mass: 0, //static
				//type: p2.Body.KINEMATIC,
				position: [x, y],
				angle: 0,
				velocity: [0, 0],
				angularVelocity: 0,
				collisionResponse: false,
				collisionGroup: 0
				//fixedRotation: true

			});
			marker._mAnchor = anchor;

			var shadowElement = new p2.Body({
				mass: 20,
				position: [x, y],
				angle: 0,
				damping: 0.9,
				velocity: [0, 0],
				angularVelocity: 0,
				collisionResponse: !marker._mIgnoreCollisions,
				fixedRotation: true
			});

			// TODO: allow users to pass in marker sizes for better perf.
			marker._mOffsetWidth = marker.div.offsetWidth;
			marker._mOffsetHeight = marker.div.offsetHeight;

			// TODO: Allow specifying different shapes
			var shape = new p2.Box({width: marker._mOffsetWidth + (marker._mMarkerBuffer * 2), height:  marker._mOffsetHeight + (marker._mMarkerBuffer * 2) });
			shadowElement.addShape(shape);

			marker._mShadowElement = shadowElement;
			shadowElement._mNumCollisions = 0;

			// Keeps things from getting too far away
			var constraint = new p2.DistanceConstraint(anchor, shadowElement, {
				collideConnected: false,
				distance: 0,
			});

			constraint.setStiffness(1000);

			marker._mConstraint = constraint;
		}

		mapObjects.get(marker._mMapId).renderCommandQueue.marker.push(marker);
		addMarkerToScene(marker);
		marker.hide();
	};

	// Adds the physics part of the marker from the scene
	var addMarkerToScene = function (marker) {
		if (marker._mAnchor) {
			markerWorld.addBody(marker._mAnchor);
			markerWorld.addBody(marker._mShadowElement);

			markerWorld.addConstraint(marker._mConstraint);
		}
		updateMarkerPosition(marker);
		scope.tryRendering();

		// Add div here?
	};

	// Cleans up and removes the physics part of the marker from the scene
	var removeMarkerFromScene = function (marker) {
		if (marker._mAnchor) {
			markerWorld.removeConstraint(marker._mConstraint);

			markerWorld.removeBody(marker._mAnchor);
			markerWorld.removeBody(marker._mShadowElement);
		}

		// Do this here?
		//scope.container.removeChild(marker.div);
		scope.tryRendering();
	};

	// Removes a maker you have added previously.
	this.removeMarker = function(marker) {
		marker.hide();
		removeMarkerFromScene(marker);
		marker.destroy();

		mapObjects.get(marker._mMapId).markers = mapObjects.get(marker._mMapId).markers.filter(function (m) {
			return marker != m;
		});

		mapObjects.get(marker._mMapId).renderCommandQueue.marker = mapObjects.get(marker._mMapId).renderCommandQueue.marker.filter(function (m) {
			return marker != m;
		});
		if (scope.container.contains(marker.div)) {
			scope.container.removeChild(marker.div);
		}
		marker.div = null;
		marker = null;
	};

	// Removes all markers
	this.removeAllMarkers = function () {
		Array.from(mapObjects.values())
			.forEach(mapObject =&gt; mapObject.removeMarkers(true));
	};

	// Displays all markers for camera movement.
	var showMarkersForCamera = function() {
		updatePhysics();
		mapManager.visibleMaps.forEach((mapObject) =&gt; {
			var markers = mapObject.markers;
			for (var i = 0, iLen = markers.length; i &lt; iLen; ++i) {
				var marker = markers[i];
				marker._mCameraHidden = false;
				marker.show();
			}
			//updatePhysics()
			for (i = 0, iLen = markers.length; i &lt; iLen; ++i) {
				updateMarkerPosition(markers[i]);
			}
		});
	};

	// Hide markers (maybe) when the camera starts moving
	var cameraMovementStart = function () {
		if (!hideMarkersOnCameraMove) {
			return;
		}
		mapManager.visibleMaps.forEach((mapObject) =&gt; {
			var markers = mapObject.markers;
			for (var i = 0, iLen = markers.length; i &lt; iLen; ++i) {
				var marker = markers[i];
				//if (marker.isColliding() || true) {
				marker._mCameraHidden = true;
				marker.hide();
				//}
			}
		});
	};

	var cameraMovementEnd = function () {
		if (!hideMarkersOnCameraMove) return;
		showMarkersForCamera();
	};

	// Takes an x/y pair in Mappedin coordinate space and gives you a Vector3 in scene space
	this.convertTo3DMapPosition = function (mappedInCoordinate) {
		var mapClass = mapObjects.get(mappedInCoordinate.map || scope.currentMap).mapClass;
		return new Vector3(
			mappedInCoordinate.x - (mapClass.width / 2),
			-mappedInCoordinate.y + (mapClass.height / 2),
			1
		);
	};

	// Gives you the top center of a polygon in 3d scene space.
	this.getPositionPolygon = function (polygon) {
		var polygonId = getObjectId(polygon);
		var target = mapObjects.get(scope.currentMap).objectsDictionary[polygonId];
		if (target) {
			// Not true center
			target.geometry.computeBoundingBox();
			var box = target.geometry.boundingBox;
			return new Vector3(
				box.min.x + (box.max.x - box.min.x) / 2,
				box.min.y + (box.max.y - box.min.y) / 2,
				box.max.z); // Or min or the middle again
		} else {
			return null;
		}
	};

	// Gives you the position of a Mappedin node in the 3D scene
	this.getPositionNode = function (node) {
		var target = node;
		if (typeof target === &quot;string&quot;) {
			target = getObject(node, venue.nodes);
		}
		return scope.convertTo3DMapPosition(target);
	};

	function updateMarkerAnchorPosition(marker) {
		var projection;

		if (marker._mMapId) {
			const mapObject = mapObjects.get(marker._mMapId);
			projection = marker._mOriginalPosition
				.clone()
				.applyMatrix4(mapObject.object.matrix)
				.project(cameraObject);
		} else {
			projection = marker._mPosition.clone().project(cameraObject);
		}

		var x = (projection.x + 1)  / 2 * canvasWidth - marker._mOffsetWidth / 2;
		var y = (-projection.y + 1) / 2 * canvasHeight - marker._mOffsetHeight / 2;

		if (isNaN(x) || isNaN(y)) {
			x = 0;
			y = 0;
		}

		p2.vec2.set(marker._mAnchor.position, x, y);
		p2.vec2.set(marker._mAnchor.previousPosition, x, y);
	}

	function round100(value) {
		return Math.trunc(value * 100) / 100;
	}

	function updateMarkerScreenPosition(marker) {
		var isAnchored = marker._mLockToAnchor || (!marker._mIgnoreCollisions &amp;&amp; !marker.isColliding());
		var position = isAnchored ?
			marker._mAnchor.position :
			marker._mShadowElement.interpolatedPosition;
		var translateX = round100(position[0]);
		var translateY = round100(position[1]);
		var rotateZ = marker._mIntitialRotation;
		if (marker._mRotateWithCamera) {
			rotateZ += scope.controls.getRotation();
		}

		var shouldUpdateTransform =
			marker.m_translateX !== translateX ||
			marker.m_translateY !== translateY ||
			marker.m_rotateZ !== rotateZ;

		if (shouldUpdateTransform) {
			marker.setTransform({ x: translateX, y:translateY, rotateZ: rotateZ });
		}
	}

	var updateMarkerPosition = function (marker) {
		updateMarkerAnchorPosition(marker);
		updateMarkerScreenPosition(marker);
	};

	// @TODO Deprecated. Leaving in for legacy support
	this.createFont = MapView3D.createFont.bind(this);

	/*
		Labels a specific polygon (or area of 3D space) with a text label that lives in 3D space.
		That means it will be smaller when the camera is further away, and the angle you see it at will change with the camera.
		The text will flip 180 degress when the camera rotates so it&#x27;s never totally upside-down.

		Possible options = {
			polygon - The polygon to make a label for
			canvasBounds - Optional, to do this without a real Mappedin Polygon
			height - If you don&#x27;t have a real polygon, you will need to set a height
			text - The text to make the label
			margin - The amount of space to leave before starting the text
			heightMargin - The amount of vertical space to leave before starting the text. Defaults to .5m. Note that increasing this will result in smaller sized text.
			multiline - Enable multline text labels or not
			color - A optional special color if you don&#x27;t want to use mapView.colors.text
			size - How big to make the text, in meters. Defaults to 1.5.
			font - A Font object, if you have your own font you want to use.
			scaleMin - What percentage we can shrink the label to if it won&#x27;t fit at 100%
			scaleStep - How much to decrement the scale each time it doesn&#x27;t fit, so we don&#x27;t end up with too many different font sizes
			hoverLabelMode3D - One of Mappedin.HoverLabel.MODES (NONE, NO_TEXT_LABEL_ONLY, ALL). Defaults to ALL
			hoverLabelClass - The CSS class to apply to the hover label
		}

		You must provide AT LEAST text and either polygon or canvasBounds + height.
	*/

	this.labelPolygon = function (options) {
		var mapObject = mapObjects.get(options.polygon.map || options.map || scope.currentMap);
		var label = new TextLabel(options, venue, mapObject, DEFAULT_FONT, polygonMeshesById, textLabelsByPolygonId, textMaterials, scope);
		mapObject.renderCommandQueue.low.push(label.create);
		textLabelsByPolygonId[options.polygon.id] = label;
		scope.tryRendering();
		return label;
	};

	// Labels all locations, displaying in order of distance from the center of the map. See labelPolygon for available options for labels
	// This function also allows you to specify a list of location Types to exclude, and your own sort order (so polygons with more than
	// one location get labeled by the most important one). By default it uses the sortOrder property.
	// You can also specify your own list of locations, if you want.
	this.labelAllLocations = function(options) {
		if (!options) {
			options = {};
		}
		var exclude = options.excludeTypes || [];
		var sortFunction = options.sortFunction;
		var locationList = options.locations || scope.venue.locations;

		var filteredList = locationList
			.filter(function(l) {
				var has = exclude.indexOf(l.type) === -1;
				return has;
			});

		// Maintain backwards compatibility for old custom sorting option
		var sortedList = filteredList;
		if (sortFunction != undefined) {
			sortedList = filteredList.sort(sortFunction);
		}

		var polygons = {};
		var polygonsSortedByDistance = [];


		for (var i = 0, iLen = sortedList.length; i &lt; iLen; ++i) {
			var locationObject = sortedList[i];
			var polygonList = locationObject.polygons;
			for (var j = 0, jLen = polygonList.length; j &lt; jLen; ++j) {
				var polygon = polygonList[j];
				if (polygons[polygon.id]) {
					continue;
				} else {
					var canvasBounds = polygon.canvasBounds;
					polygons[polygon.id] = true;

					var mapClass = mapObjects.get(scope.currentMap).mapClass;

					var d = 0;
					if (canvasBounds) {
						var x = (canvasBounds.x - (mapClass.width / 2));
						var y = (-canvasBounds.y + (mapClass.height / 2));
						d = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
					}
					var text = locationObject.name;
					if (sortFunction == undefined) {
						text = scope.getPrimaryLocationForPolygon(polygon).name;
					}
					polygonsSortedByDistance.push({
						polygon: polygon,
						text: text,
						distance: d
					});
				}
			}
		}
		polygonsSortedByDistance.sort(function (a, b) { return b.distance - a.distance;});
		for (var k = 0, kLen = polygonsSortedByDistance.length; k &lt; kLen; ++k) {
			var polyData = polygonsSortedByDistance[k];
			options.polygon = polyData.polygon;
			options.text = polyData.text;
			scope.labelPolygon(options);
		}
	};

	// Removes all labels on the scene
	this.removeAllLabels = function() {
		mapManager.mapObjectsSortedByElevation.forEach(mapObject =&gt; mapObject.removeLabels());
		textLabelsByPolygonId = {};
		// Temporary solution until https://github.com/mrdoob/three.js/issues/12447 is addressed
		renderer.renderLists.dispose();
	};

	// Let any image attached to a polygon attached to a location rotate with the camera so it&#x27;s always upright
	this.enableImageFlippingForAllLocations = function (options) {
		if (!options) {
			options = {};
		}
		var exclude = options.excludeTypes || [];
		var locationList = options.locations || scope.venue.locations.slice();

		var filteredList = locationList
			.filter(function(l) {
				var has = exclude.indexOf(l.type) === -1;
				return has;
			});

		var polygons = {};

		for (var i = 0, iLen = filteredList.length; i &lt; iLen; ++i) {
			var location = filteredList[i];
			var polygonList = location.polygons;
			for (var j = 0, jLen = polygonList.length; j &lt; jLen; ++j) {
				var polygon = polygonList[j];
				if (polygons[polygon.id]) {
					continue;
				} else {
					polygons[polygon.id] = true;
					scope.enableImageFlippingForPolygon({
						polygon: polygon
					});
				}
			}
		}
	};

	// Mark a specific polygon so, if it has an image, it rotates with the camera
	this.enableImageFlippingForPolygon = function(options) {
		if (options == null || (options.polygon == null &amp; options.polygonId == null)) { return; }
		var polygonId = options.polygon.id || options.polygonId;
		var polygon = options.polygon;
		var mapObject = mapObjects.get(options.map || polygon ? polygon.map : scope.currentMap);
		var rotation = 0;
		var perspectiveId = mapObjects.get(scope.currentMap).mapClass.perspectiveId;

		// Manually set rotation
		if (options.rotation &amp;&amp; !isNaN(options.rotation)) {
			rotation = options.rotation * (Math.PI / 180);
		// Rotation for the current perspective
		} else if (perspectiveId &amp;&amp; polygon &amp;&amp; polygon.perspectives &amp;&amp; polygon.perspectives[perspectiveId]
				&amp;&amp; polygon.perspectives[perspectiveId].image &amp;&amp; polygon.perspectives[perspectiveId].image.rotation &amp;&amp; !isNaN(polygon.perspectives[perspectiveId].image.rotation.z)) {
			rotation = polygon.perspectives[perspectiveId].image.rotation.z * (Math.PI / 180);
		// Default rotation
		} else if (options.polygon &amp;&amp; options.polygon.image &amp;&amp; options.polygon.image.rotation &amp;&amp; !isNaN(options.polygon.image.rotation.z)) {
			rotation = options.polygon.image.rotation.z * (Math.PI / 180);
		} else {
			// This is still ok, if the image hasn&#x27;t been rotated at all.
		}

		if (polygonId) {
			mapObject.load().then(function () {
				mapObject.enableImageFlipping(polygonId, rotation);
			});
		}
	};

	this.disableImageFlippingForAllPolygons = function () {
		var maps = Object.keys(mapObjects);
		for (var i = 0, iLen = maps.length; i &lt; iLen; i++) {
			var map = maps[i];
			mapObjects.get(map).disableAllImageFlipping();
		}
	};

	// Calculates the length of the connected path in list of Mappedin Nodes. Breaks in the path (to go to other floors) count as 0 distance. The Z value is also ignored.
	this.getPathLength = function(path) {
		var length = 0;
		for (var i = 0, iLen = path.length - 1; i &lt; iLen; ++i) {
			var node = path[i];
			var nextNode = path[i + 1];
			if (node.path.includes(nextNode)) {
				length += Math.sqrt(Math.pow((nextNode.x - node.x), 2) + Math.pow((nextNode.y - node.y), 2));
			}
		}
		return length;
	};

	/*

	 Draws an entire path. It takes a list of nodes and will break them into separate path segments on every man change, putting the resultant segment on the right map.

	 If you have a special use case (like off graph nodes, or venues with same map vortexes) use the drawPathSegment function.

	 Returns an array of path segments if you want to customize the animation triggers. The path segments are added to the scene, chained together, and start animating automatically.


	 options = {
		// Color of path
		color: 0xff834c,
		// Color of the pulse that flys through the path a few times to show direction
		pulseColor: 0xffffff,
		// Number of times the pulse will iterate before pausing. The scene can&#x27;t sleep while something is animating, which is bad for battery on mobile devices
		pulseIterations: Infinity,
		// Radius of path tube
		radius: 10,
		// Duration of fade in animation
		drawDuration: 3000,
		// Tween.js curve to use for fade in animation
		curve: TWEEN.Easing.Circular.InOut,
		// draw connection path segments between levels
		drawConnectionSegments: false
		// override connection path segment options
		connectionPathOptions: {
			// Color of path
			color: 0x7dd322,
			// Color of the pulse that flys through the path a few times to show direction
			pulseColor: 0xffffff,
			// Number of times the pulse will iterate before pausing. The scene can&#x27;t sleep while something is animating, which is bad for battery on mobile devices
			pulseIterations: Infinity,
			// Radius of path tube
			radius: 10,
			// Duration of fade in animation
			drawDuration: 1500,
			// Tween.js curve to use for fade in animation
			curve: TWEEN.Easing.Circular.InOut
		}
	 }
	 */
	this.drawPath = function (path, options) {
		var start = 0;
		var map = path[start].map || scope.currentMap;

		var segments = [];

		var currentSegment = null;
		// Generate all the path segments not on the final map
		for (var i = 0, iLen = path.length; i &lt; iLen; ++i) {
			var node = path[i];

			if (node.map &amp;&amp; node.map != map) {
				if (path[i - 1] != null &amp;&amp; options.drawConnectionSegments === true) {
					const connectionSegment = scope.drawConnectionPathSegment([path[i - 1], path[i]], options.connectionPathOptions);
					if (currentSegment) {
						currentSegment.tween.chain(connectionSegment.tween);
					}
					segments.push(connectionSegment);
					currentSegment = connectionSegment;
				}
				const segment = scope.drawPathSegment(path.slice(start, i), map, options);

				start = i;
				map = node.map;

				if (currentSegment) {
					currentSegment.tween.chain(segment.tween); //, segment.pulseTween)
				} else {
					// This is fine?
				}
				currentSegment = segment;
				segments.push(segment);
			}
		}
		// Generate the final segment on the final map
		let segment = scope.drawPathSegment(path.slice(start), map, options);
		if (currentSegment) {
			currentSegment.tween.chain(segment.tween);
		} else {
			// This is fine?
		}
		segments.push(segment);
		var startSegment = segments[0];
		startSegment.tween.start();

		for (let i = 0; i &lt; segments.length; i++) {
			// @TODO: figure out why repeats is killing the CPU
			segments[i].pulseTween.repeat((options &amp;&amp; options.pulseIterations || Infinity) + i).start();
		}
		scope.tryRendering();

		return segments;
	};

	function drawSegment(vectorPoints, path, options) {
		options = options || {};
		const color = options.color || scope.colors.path || 0xff834c;
		const pulseColor = options.pulseColor || scope.colors.pathPulse || 0xffffff;
		const pulseIterations = options.pulseIterations || Infinity;
		const radius = options.radius || 10;
		const drawDuration = options.drawDuration || 3000;
		const curve = options.curve || TWEEN.Easing.Circular.InOut;

		const uniforms = {
			vertexes: {
				type: &quot;f&quot;,
				value: 1.0
			},
			resolution: {
				type: &quot;v2&quot;,
				value: new Vector2()
			},
			complete: {
				type: &quot;f&quot;,
				value: 0.0
			},
			color: {
				type: &quot;c&quot;,
				value: new Color(color)
			},
			pulseColor: {
				type: &quot;c&quot;,
				value: new Color(pulseColor)
			},
			pulse: {
				type: &quot;f&quot;,
				value: 0.0
			},
			pulseLength: {
				type: &quot;f&quot;,
				value: 0.05
			},
			pulseBulge: {
				type: &quot;b&quot;,
				value: false
			}
		};

		const pathCurve = new CatmullRomCurve3(vectorPoints);

		pathCurve.curveType = &#x27;catmullrom&#x27;;
		pathCurve.tension = 0.0;

		const geometry = new TubeGeometry(pathCurve, path.length * 30, radius, 8, false);

		const bufferGeometry = new BufferGeometry().fromGeometry(geometry);

		const vertexIndex = new Float32Array(bufferGeometry.attributes.position.count);

		for (let i = path.length; i &lt; vertexIndex.length; i++) {
			vertexIndex[i] = i;
		}

		bufferGeometry.addAttribute(&#x27;vertexIndex&#x27;, new BufferAttribute(vertexIndex, 1));

		//Sweet shader material
		const material = new ShaderMaterial({
			uniforms: uniforms,
			vertexShader: Shaders.VertexShader,
			fragmentShader: Shaders.FragmentShader,
		});

		material.transparent = true;
		material.alphaTest = 0.5;

		// I am not 100% sure if this is still needed. We could spend a lot of time on cool shaders.
		uniforms.resolution.value.x = 100; //width
		uniforms.resolution.value.y = 100; //height

		uniforms.vertexes.value = vertexIndex.length;

		const pathObject = new Mesh(bufferGeometry, material);

		const pulseTween = new TWEEN.Tween(uniforms.pulse).to({value: 1.0}, drawDuration)
			.easing(curve)
			.onUpdate(scope.tryRendering);

		pulseTween.repeat(pulseIterations);

		const tween = new TWEEN.Tween(uniforms.complete).to({value: 1.0}, drawDuration)
			.easing(curve)
			.onUpdate(scope.tryRendering);

		const pathSegment = {
			id: pathObject.id,
			object: pathObject,
			tween: tween,
			pulseTween: pulseTween,
			reset: function () {
				uniforms.complete.value = 0.0;
			}
		};

		return pathSegment;
	}

	/*
		Takes a list of {x, y} pairs in Mappedin coordinate space and draws a connected path on the specified map. Use this function for special cases not handled by the drawPath convenience function.

		Returns a path segment. You will need to call it&#x27;s tween.start() function to begin animation and make the path segment visible.
		You can customize the Tween.js tween if you like, but make sure tryRendering is always called in onUpdate or the path may stop.

		options = {
		// Color of path
		color: 0xff834c,
		// Color of the pulse that flys through the path a few times to show direction
		pulseColor: 0xffffff,
		// Number of times the pulse will iterate before pausing. The scene can&#x27;t sleep while something is animating, which is bad for battery on mobile devices
		pulseIterations: Infinity,
		// Radius of path tube
		radius: 10,
		// Duration of fade in animation
		drawDuration: 3000,
		// Tween.js curve to use for fade in animation
		curve: TWEEN.Easing.Circular.InOut
	 }
	*/
	this.drawPathSegment = function(
		path,
		map,
		options = {
			color: 0xff834c,
			pulseColor: 0xffffff,
			pulseIterations: Infinity,
			radius: 10,
			drawDuration: 3000,
			curve: TWEEN.Easing.Circular.InOut
		}) {
		const mapId = map ? getObjectId(map) : scope.currentMap;
		const radius = options.radius || 10;

		const vectorPoints = [];
		const mapClass = mapObjects.get(mapId).mapClass;

		for (let i = 0; i &lt; path.length; i++) {
			const v = path[i];
			const vector = new Vector3(
				v.x - (mapClass.width / 2),
				-v.y + (mapClass.height / 2),
				radius / 2);
			vectorPoints.push(vector);
		}

		vectorPoints.push(vectorPoints[vectorPoints.length - 1].clone().setZ(-radius));
		vectorPoints.unshift(vectorPoints[0].clone().setZ(-radius));

		const pathSegment = drawSegment(vectorPoints, path, options);

		pathSegments[pathSegment.id] = pathSegment;
		mapObjects.get(mapId).add(pathSegment.object);

		return pathSegment;
	};


	/*
		Takes two {x, y} pairs in Mappedin coordinate space and draws a connected path between them, typically to connect two levels together

		Returns a path segment. You will need to call it&#x27;s tween.start() function to begin animation and make the path segment visible.
		You can customize the Tween.js tween if you like, but make sure tryRendering is always called in onUpdate or the path may stop.

		options = {
		// Color of path
		color: 0x7dd322,
		// Color of the pulse that flys through the path a few times to show direction
		pulseColor: 0xffffff,
		// Number of times the pulse will iterate before pausing. The scene can&#x27;t sleep while something is animating, which is bad for battery on mobile devices
		pulseIterations: Infinity,
		// Radius of path tube
		radius: 10,
		// Duration of fade in animation
		drawDuration: 1500,
		// Tween.js curve to use for fade in animation
		curve: TWEEN.Easing.Circular.InOut
	 }
	*/
	this.drawConnectionPathSegment = function(
		path,
		options = {
			color: 0x7dd322,
			pulseColor: 0xffffff,
			pulseIterations: Infinity,
			radius: 20,
			drawDuration: 1500,
			curve: TWEEN.Easing.Circular.InOut
		}) {
		const startMap = mapObjects.get(path[0].map);
		const endMap = mapObjects.get(path[1].map);

		const startMapClass = startMap.mapClass;
		const endMapClass = endMap.mapClass;

		const fromNode = new Vector3(
			path[0].x - (startMapClass.width / 2),
			-path[0].y + (startMapClass.height / 2),
			0
		);

		const toNode = new Vector3(
			path[1].x - (endMapClass.width / 2),
			-path[1].y + (endMapClass.height / 2),
			0
		);

		const fromNodeAdjusted = fromNode.clone().applyMatrix4(startMap.object.matrix);
		const toNodeAdjusted = toNode.clone().applyMatrix4(endMap.object.matrix);

		const vectorPoints = [fromNodeAdjusted, toNodeAdjusted];
		const pathSegment = drawSegment(vectorPoints, path, options);

		pathSegments[pathSegment.id] = pathSegment;
		scope.scene.add(pathSegment.object);

		return pathSegment;
	};

	// Removes a specific path segment
	this.removePathSegment = function (pathSegment) {
		if (pathSegment) {
			// Make this a cool transition later
			pathSegment.object.destroy();
			pathSegment.pulseTween.stop();
			pathSegment.tween.stop();
			pathSegment.pulseTween = undefined;
			pathSegment.tween = undefined;
			pathSegments[pathSegment.id] = undefined;
		}
	};

	// Removes all paths from the map
	this.removeAllPaths = function() {
		var keys = Object.keys(pathSegments);
		for (var i = 0, iLen = keys.length; i &lt; iLen; i++) {
			scope.removePathSegment(pathSegments[keys[i]]);
		}
		// Temporary solution until https://github.com/mrdoob/three.js/issues/12447 is addressed
		renderer.renderLists.dispose();
	};

	// Sets the clear color of the 3D scene to something else, it you want it to fit it more with your website.
	this.setBackgroundColor = function(color, alpha) {
		if (shouldConsiderAlpha) {
			alpha = alpha !== undefined ? +alpha : 1;
			alpha = alpha &gt;= 0 &amp;&amp; alpha &lt;= 1 ? alpha : 1;
			renderer.setClearColor(color, alpha);
		} else {
			renderer.setClearColor(color);
		}
	};

	var doHoverEffect = function () {
		if (disableHover) { return; }
		var polygons = detectPolygonsUnderMouse();

		var hovering = false;
		for (var i = 0, iLen = polygons.length; i &lt; iLen; ++i) {
			var polygon = polygons[i];
			if (interactivePolygons[polygon]) {
				if (polygon != lastHover) {
					if (lastHover) {
						onPolygonHoverOut(lastHover);
						lastHover = null;
					}

					if (!highlightedPolygons[polygon]) {
						lastHover = polygon;
						onPolygonHoverOver(polygon);
					}
					var textLabel = textLabelsByPolygonId[getObjectId(polygon)];
					if (textLabel &amp;&amp; textLabel.showHoverLabel) {
						hoverLabel.show(textLabel);
					} else {
						hoverLabel.hide();
					}
				}

				hovering = true;
				break;
			}
		}

		if (hovering == false) {
			if (lastHover) {
				onPolygonHoverOut(lastHover);
				lastHover = null;
			}
			hoverLabel.hide();
		}
	};

	this.setSize = function (width, height) {
		// look up the size the canvas is being displayed in CSS pixels
		canvasWidth = renderer.domElement.clientWidth;
		canvasHeight = renderer.domElement.clientHeight;

		// guess the width and height js will use if we ask for that size
		var widthThreeJS = Math.floor(width * scope.resolutionScale);
		var heightThreeJS = Math.floor(height * scope.resolutionScale);

		if (!disableZoomOnMapSizeChange) {
			// check if our canvas is that widthThreeJS
			var factor = renderer.domElement.width !== widthThreeJS ? renderer.domElement.width / widthThreeJS : renderer.domElement.height / heightThreeJS;

			scope.controls.setZoom(factor * scope.controls.getZoom());
		}
		// it&#x27;s not the same size so
		// set it to the width and height we want and pray
		// that it matches what js actually uses
		renderer.setSize(widthThreeJS, heightThreeJS, false);
		cameraObject.aspect = widthThreeJS / heightThreeJS;
		cameraObject.updateProjectionMatrix();
		cameraObject.updateMatrixWorld(true);
	};

	// Renders the scene. It will also do things that should happen on every frame like:
	// 	- Changing the render size, if needed.
	// 	- Update the camera controls
	// 	- Highlight the current polygon that is being moused over
	//  - Moves all markers to their correct position
	//	- Rotates all text labels if needed
	//	- Executes as many commands as possible in the renderCommandQueue
	var requestAnimationFrameHandle = 0;
	var fixedTimeStep = 1 / 30;
	var lastTimeSeconds = 0;
	var maxSubSteps = 10;
	var render = function(animationTime) {
		requestAnimationFrameHandle = 0;

		if (contextLost === true || renderer == null) {
			return;
		}

		// Don&#x27;t render at all if we have no map
		if (scope.currentMap == null) {
			return;
		}

		if (scope.shouldMeasureCanvas) {
			// look up the size the canvas is being displayed in CSS pixels
			var width = canvasWidth = renderer.domElement.clientWidth;
			var height = canvasHeight = renderer.domElement.clientHeight;

			// guess the width and height js will use if we ask for that size
			var widthThreeJS = Math.floor(width * scope.resolutionScale);
			var heightThreeJS = Math.floor(height * scope.resolutionScale);

			// check if our canvas is that widthThreeJS
			if (renderer.domElement.width !== widthThreeJS ||
					renderer.domElement.height !== heightThreeJS) {
				var factor = renderer.domElement.width !== widthThreeJS ? renderer.domElement.width / widthThreeJS : renderer.domElement.height / heightThreeJS;

				scope.controls.setZoom(factor * scope.controls.getZoom());
				// it&#x27;s not the same size so
				// set it to the width and height we want and pray
				// that it matches what js actually uses
				renderer.setSize(widthThreeJS, heightThreeJS, false);
				cameraObject.aspect = widthThreeJS / heightThreeJS;
				cameraObject.updateProjectionMatrix();
				//console.log(&quot;Mapview resized to &quot; + widthThreeJS + &quot;x&quot; + heightThreeJS)
			}
		}
		scope.controls.update();

		// Check if we are hovering over a polygon
		if (scope.controls.isCameraMoving()) {
			if (lastHover) {
				onPolygonHoverOut(lastHover);
				lastHover = null;
			}
			if (hoverLabel.hovering) {
				hoverLabel.hide();
			}
		}


		renderer.render(scope.scene, cameraObject);
		if (scope.controls.postRender) {
			scope.controls.postRender();
		}

		var north = scope.getNorth() + scope.controls.getRotation();
		for (var i = 0, iLen = rotateWithCamera.length; i &lt; iLen; ++i) {
			rotateNode(rotateWithCamera[i], north);
		}

		rotateTextLabels();
		rotateImages();
		flippablesNeedUpdating = false;

		renderFrames--;
		if (renderFrames &gt; 0 &amp;&amp; requestAnimationFrameHandle === 0) {
			requestAnimationFrameHandle = requestAnimationFrame(render);
		}

		var timeSeconds = animationTime / 1000;
		if (!lastTimeSeconds) lastTimeSeconds = timeSeconds;
		var deltaTime = timeSeconds - lastTimeSeconds;

		markerWorld.step(fixedTimeStep, deltaTime, maxSubSteps);

		mapManager.visibleMaps.forEach((mapObject) =&gt; {
			mapObject.markers.forEach(updateMarkerAnchorPosition);
			mapObject.markers.forEach(updateMarkerScreenPosition);

			var renderCommandQueue = mapObject.renderCommandQueue;
			if (renderCommandQueue.high.length &gt; 0 || renderCommandQueue.low.length &gt; 0) {
				do {
					var command = renderCommandQueue.high.length &gt; 0 ? renderCommandQueue.high.pop() : renderCommandQueue.low.pop();
					command();
					scope.tryRendering();
				} while (Date.now() &lt; nextFrameTime &amp;&amp; (renderCommandQueue.high.length &gt; 0 || renderCommandQueue.low.length &gt; 0));
				nextFrameTime = Date.now() + MAX_TIME_PER_FRAME;
			} else {
				if (mapObject.mapLoaded &amp;&amp; typeof mapObject.mapLoaded === typeof Function) {
					mapObject.mapLoaded();
					mapObject.mapLoaded = null;
					//console.timeEnd(&quot;setmap&quot;)
				}
			}
			if (renderCommandQueue.high.length == 0 &amp;&amp; renderCommandQueue.marker.length &gt; 0) {
				for (let i = 0; i &lt; renderCommandQueue.marker.length; i++) {
					var marker = renderCommandQueue.marker[i];
					if (!marker._mDeleted) {
						mapObject.markers.push(marker);
						updateMarkerPosition(marker);
						marker.show();
					}
				}
				renderCommandQueue.marker = [];
				scope.tryRendering();
			}
		});
		updatePhysics();
	};

	var bonusFrames = 15; // Render this many frames after the last tryRender call to account for physics

	// The scene only renders when something has changed. This should be something a 3rd party developer doesn&#x27;t need to worry about,
	// but if you are doing something weird, or have your own special tween for something, you will want to call this function.
	// You can call it as often as you want, it just sets a flag that we need to render again, and renders a few frames if we weren&#x27;t already doing that.
	this.tryRendering = function () {
		renderFrames = bonusFrames;
		if (requestAnimationFrameHandle === 0) {
			requestAnimationFrameHandle = requestAnimationFrame(render);
		}
	};

	// Updates the physics engine a whole bunch to make markers settle down
	var updatePhysics = function () {
		markerWorld.step(physicsResolution, physicsTime, physicsTime * physicsResolution);
	};

	// Rotates all the text labels if needed
	var rotateTextLabels = function () {
		var angle = cameraOrbit.rotation.z;

		if (rotating || flippablesNeedUpdating) {
			mapManager.visibleMaps.forEach((mapObject) =&gt; {
				var textObjects = mapObject.textObjects;
				for (var i = 0, iLen = textObjects.length; i &lt; iLen; ++i) {
					var textObject = textObjects[i];
					textObject.flipIfNeeded(angle);
				}
			});
		}
	};

	// Rotates all the images
	var rotateImages = function () {
		var angle = cameraOrbit.rotation.z;

		if (rotating || flippablesNeedUpdating) {
			mapManager.visibleMaps.forEach((mapObject) =&gt; {
				var images = mapObject.imagesToFlip;
				for (var i = 0, iLen = images.length; i &lt; iLen; ++i) {
					var image = images[i];
					image.flipIfNeeded(angle);
				}
			});
		}
	};

	// Set up all our events
	container.appendChild(renderer.domElement);

	container.style.touchAction = &#x27;auto&#x27;;

	// Check if browser supports pointerEvent, which is ideal to support mouse/touch
	if (window.PointerEvent) {
		//https://mobiforge.com/design-development/html5-pointer-events-api-combining-touch-mouse-and-pen
		renderer.domElement.addEventListener(&#x27;pointerdown&#x27;, onMouseDown, false);
		renderer.domElement.addEventListener(&#x27;pointermove&#x27;, onMouseMove, false);
		renderer.domElement.addEventListener(&#x27;pointerup&#x27;, onMouseUp, false);
		renderer.domElement.addEventListener(&#x27;pointercancel&#x27;, onMouseUp, false);
	} else {
		renderer.domElement.addEventListener(&#x27;mousemove&#x27;, onMouseMove, false);
		renderer.domElement.addEventListener (&#x27;mousedown&#x27;, onMouseDown, false);
		renderer.domElement.addEventListener (&#x27;mouseup&#x27;, onMouseUp, false);
		renderer.domElement.addEventListener (&#x27;mouseleave&#x27;, onMouseMove, false);
		renderer.domElement.addEventListener(&#x27;touchstart&#x27;, onTouchStart, false);
		renderer.domElement.addEventListener(&#x27;touchend&#x27;, onTouchEnd, false);
		renderer.domElement.addEventListener(&#x27;touchcancel&#x27;, onTouchEnd, false);
	}

	window.addEventListener(&#x27;resize&#x27;, onWindowResize, false);

	container.style.overflow = &quot;hidden&quot;;
	renderer.domElement.style.width = &quot;100%&quot;;
	renderer.domElement.style.height = &quot;100%&quot;;

	var canvasWidth = renderer.domElement.clientWidth;
	var canvasHeight = renderer.domElement.clientHeight;

	/**
	* True if the canvas should be measured every frame. This is ideal to handle the user resizing the browser window on occasion, but
	* may not be optimal if you are trying to resize the MapView dynamically all the time.
	*
	* @property shouldMeasureCanvas {Boolean}
	*/
	this.shouldMeasureCanvas = true;

	// Default color and size
	this.setBackgroundColor(backgroundColor, backgroundAlpha);

	renderer.setSize(Math.floor(canvasWidth * scope.resolutionScale), Math.floor(canvasHeight * scope.resolutionScale), false);

	// Perform initial render so canvas is drawn with background color
	renderer.render(this.scene, cameraObject);

	// Prepare the default font
	var DEFAULT_FONT = scope.createFont(DEFAULT_FONT_JSON);

	// These light settings mirror what things look liked in the Mappedin CMS. This may be customizable in the future.
	var directionalLight = new DirectionalLight(0xffffff, 0.3);
	directionalLight.position.set(-150, -150, 350);

	this.scene.add(directionalLight);

	var hemisphericalLight = new HemisphereLight(0xffffff, 0xffffff, 0.77);
	this.scene.add(hemisphericalLight);

	var renderFrames = 0;

	// Set up the camera controls
	this.controls = new Mappedin.CameraControls(cameraObject, renderer.domElement, this.scene, this);
	this.controls.enableZoom = true;

	this.INTERACTION_EVENTS = this.controls.INTERACTION_EVENTS;

	// Hook up camera events to the markers and render loop
	this.controls.addEventListener(this.controls.CAMERA_EVENTS.CHANGE_EVENT.type, scope.tryRendering);

	this.controls.addEventListener(this.controls.CAMERA_EVENTS.ZOOM_START_EVENT.type, cameraMovementStart);
	this.controls.addEventListener(this.controls.CAMERA_EVENTS.ROTATE_START_EVENT.type, cameraMovementStart);
	this.controls.addEventListener(this.controls.CAMERA_EVENTS.ROTATE_START_EVENT.type, cameraRotationStarted);	// Text labels
	this.controls.addEventListener(this.controls.CAMERA_EVENTS.MULTI_START_EVENT.type, cameraMovementStart);
	this.controls.addEventListener(this.controls.CAMERA_EVENTS.MULTI_START_EVENT.type, clearMouse);
	this.controls.addEventListener(this.controls.CAMERA_EVENTS.MULTI_START_EVENT.type, cameraRotationStarted);
	this.controls.addEventListener(this.controls.CAMERA_EVENTS.PAN_START_EVENT.type, cameraMovementStart);
	this.controls.addEventListener(this.controls.CAMERA_EVENTS.PAN_START_EVENT.type, clearMouse);

	this.controls.addEventListener(this.controls.CAMERA_EVENTS.ZOOM_END_EVENT.type, cameraMovementEnd);
	this.controls.addEventListener(this.controls.CAMERA_EVENTS.ROTATE_END_EVENT.type, cameraMovementEnd);
	this.controls.addEventListener(this.controls.CAMERA_EVENTS.ROTATE_END_EVENT.type, cameraRotationStopped);
	this.controls.addEventListener(this.controls.CAMERA_EVENTS.MULTI_END_EVENT.type, cameraMovementEnd);
	this.controls.addEventListener(this.controls.CAMERA_EVENTS.MULTI_END_EVENT.type, cameraRotationStopped);
	this.controls.addEventListener(this.controls.CAMERA_EVENTS.PAN_END_EVENT.type, cameraMovementEnd);

	this.controls.addEventListener(this.controls.INTERACTION_EVENTS.USER_PAN_EVENT.type, function() {
		scope.currentInteractionEvent = &#x27;user-pan&#x27;;
	});

	this.controls.addEventListener(this.controls.INTERACTION_EVENTS.USER_ROTATE_EVENT.type, function() {
		scope.currentInteractionEvent = &#x27;user-rotate&#x27;;
	});

	this.controls.addEventListener(this.controls.INTERACTION_EVENTS.USER_DOLLY_EVENT.type, function() {
		scope.currentInteractionEvent = &#x27;user-zoom&#x27;;
	});

	this.controls.addEventListener(this.controls.INTERACTION_EVENTS.USER_TILT_EVENT.type, function() {
		scope.currentInteractionEvent = &#x27;user-tilt&#x27;;
	});

	this.controls.addEventListener(this.controls.INTERACTION_EVENTS.USER_ZOOM_EVENT.type, function() {
		scope.publish(&#x27;user-zoom&#x27;);
	});

	// Display map the developer said to load first, or the default map if it&#x27;s set, otherwise use just first one (which is in an undefined order)
	var startingMap;
	var maps = venue.maps;
	var targetMap = venue.venue.defaultMap;
	if (options &amp;&amp; options.firstMap) {
		targetMap = getObjectId(options.firstMap);
	}

	if (targetMap) {
		for (var i = 0, iLen = maps.length; i &lt; iLen; ++i) {
			if (maps[i].id === targetMap) {
				startingMap = maps[i].id;
				break;
			}
		}
	}
	if (!startingMap) {
		startingMap = maps[0].id;
	}

	var setFlippablesNeedUpdating = function(value = true) {
		flippablesNeedUpdating = value;
	};

	function renderImmediately() {
		renderer.render(scope.scene, cameraObject);
	}

	mapManager.on(&#x27;render&#x27;, scope.tryRendering);
	mapManager.on(&#x27;render:now&#x27;, renderImmediately);
	mapManager.on(&#x27;flippablesNeedUpdating&#x27;, setFlippablesNeedUpdating);
	mapManager.on(&#x27;updateMarkerPosition&#x27;, updateMarkerPosition);

	mapManager.loadMaps(maps, startingMap, options.onFirstMapLoaded, options.onDataLoaded);

	/**
	* Destroys instance and frees resources
	*
	* @method destroy
	*/
	this.destroy = function() {
		this.controls.dispose();
		mapManager.off(&#x27;render&#x27;);
		mapManager.off(&#x27;render:now&#x27;);
		mapManager.off(&#x27;flippablesNeedUpdating&#x27;);
		mapManager.off(&#x27;updateMarkerPosition&#x27;);

		renderer.domElement.removeEventListener(&#x27;webglcontextcreationerror&#x27;, reportWebGlContextCreationError);
		renderer.domElement.removeEventListener(&#x27;webglcontextlost&#x27;, reportWebGlContextLost);
		renderer.domElement.removeEventListener(&#x27;webglcontextrestored&#x27;, onWebGLContextRestored);

		// Check if browser supports pointerEvent, which is ideal to support mouse/touch
		if (window.PointerEvent) {
			//https://mobiforge.com/design-development/html5-pointer-events-api-combining-touch-mouse-and-pen
			renderer.domElement.removeEventListener(&#x27;pointerdown&#x27;, onMouseDown, false);
			renderer.domElement.removeEventListener(&#x27;pointermove&#x27;, onMouseMove, false);
			renderer.domElement.removeEventListener(&#x27;pointerup&#x27;, onMouseUp, false);
			renderer.domElement.removeEventListener(&#x27;pointercancel&#x27;, onMouseUp, false);
		} else {
			renderer.domElement.removeEventListener(&#x27;mousemove&#x27;, onMouseMove, false);
			renderer.domElement.removeEventListener(&#x27;mousedown&#x27;, onMouseDown, false);
			renderer.domElement.removeEventListener(&#x27;mouseup&#x27;, onMouseUp, false);
			renderer.domElement.removeEventListener(&#x27;mouseleave&#x27;, onMouseMove, false);
			renderer.domElement.removeEventListener(&#x27;touchstart&#x27;, onTouchStart, false);
			renderer.domElement.removeEventListener(&#x27;touchend&#x27;, onTouchEnd, false);
			renderer.domElement.removeEventListener(&#x27;touchcancel&#x27;, onTouchEnd, false);
		}

		window.removeEventListener(&#x27;resize&#x27;, onWindowResize, false);

		// Hook up camera events to the markers and render loop
		scope.controls.removeEventListener(scope.controls.CAMERA_EVENTS.CHANGE_EVENT.type, scope.tryRendering);

		scope.controls.removeEventListener(scope.controls.CAMERA_EVENTS.ZOOM_START_EVENT.type, cameraMovementStart);
		scope.controls.removeEventListener(scope.controls.CAMERA_EVENTS.ROTATE_START_EVENT.type, cameraMovementStart);
		scope.controls.removeEventListener(scope.controls.CAMERA_EVENTS.ROTATE_START_EVENT.type, cameraRotationStarted);	// Text labels
		scope.controls.removeEventListener(scope.controls.CAMERA_EVENTS.MULTI_START_EVENT.type, cameraMovementStart);
		scope.controls.removeEventListener(scope.controls.CAMERA_EVENTS.MULTI_START_EVENT.type, clearMouse);
		scope.controls.removeEventListener(scope.controls.CAMERA_EVENTS.MULTI_START_EVENT.type, cameraRotationStarted);
		scope.controls.removeEventListener(scope.controls.CAMERA_EVENTS.PAN_START_EVENT.type, cameraMovementStart);
		scope.controls.removeEventListener(scope.controls.CAMERA_EVENTS.PAN_START_EVENT.type, clearMouse);

		scope.controls.removeEventListener(scope.controls.CAMERA_EVENTS.ZOOM_END_EVENT.type, cameraMovementEnd);
		scope.controls.removeEventListener(scope.controls.CAMERA_EVENTS.ROTATE_END_EVENT.type, cameraMovementEnd);
		scope.controls.removeEventListener(scope.controls.CAMERA_EVENTS.ROTATE_END_EVENT.type, cameraRotationStopped);
		scope.controls.removeEventListener(scope.controls.CAMERA_EVENTS.MULTI_END_EVENT.type, cameraMovementEnd);
		scope.controls.removeEventListener(scope.controls.CAMERA_EVENTS.MULTI_END_EVENT.type, cameraRotationStopped);
		scope.controls.removeEventListener(scope.controls.CAMERA_EVENTS.PAN_END_EVENT.type, cameraMovementEnd);

		markerWorld.off(&quot;beginContact&quot;, onCollisionStart);
		markerWorld.off(&quot;endContact&quot;, onCollisionEnd);

		scope.removeAllPaths();
		scope.removeAllLabels();
		scope.removeAllMarkers();
		scope.disableImageFlippingForAllPolygons();
		mapManager.destroy();
		scope.scene.destroy();
		hoverLabel.destroy();
		interactivePolygons = {};
		renderer.dispose();
		container.removeChild(renderer.domElement);
		renderer = undefined;
	};
};

// Create a font by passing in a JSON object generated from https://gero3.github.io/facetype.js/
MapView3D.createFont = function (facetypeJson) {
	var combinedFontObject = {};
	var combinedGlyphSet = {};
	Object.keys(facetypeJson.glyphs).forEach(function(key) {
		combinedGlyphSet[key] = facetypeJson.glyphs[key];
	});
	Object.keys(DEFAULT_FONT_JSON.glyphs).forEach(function(key) {
		combinedGlyphSet[key] = DEFAULT_FONT_JSON.glyphs[key];
	});

	Object.keys(DEFAULT_FONT_JSON).forEach(function(key) {
		combinedFontObject[key] = DEFAULT_FONT_JSON[key];
	});
	combinedFontObject.glyphs = combinedGlyphSet;
	var font = new Font(combinedFontObject);

	// Joins all the glyphs togther into one string and escapes any special characters to use in our RegEx
	font._mSupportedCharacters = Object.keys(combinedFontObject.glyphs).join(&quot;&quot;);

	// Hack to hide ® until we solve that problem
	//font._mSupportedCharacters = font._mSupportedCharacters .replace(/®/g, &quot;&quot;)

	var unicode = font._mSupportedCharacters.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, &quot;\\$&amp;&quot;);
	font._mInvalidCharacters = new RegExp(&quot;[^&quot; + unicode + &quot;]&quot;, &#x27;g&#x27;);
	return font;
};

MapView3D.Marker = Marker;

export default MapView3D;

    </pre>
</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script src="../assets/vendor/prettify/prettify-min.js"></script>
    <script>prettyPrint();</script>
    <script src="../assets/vendor/jquery/jquery.min.js"></script>
    <script src="../assets/vendor/jquery-ui/jquery-ui.min.js"></script>
    <script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
    <script src="../assets/vendor/github-slugger/slugger.js"></script>
    <script src="../assets/js/yuidoc-bootstrap.js"></script>
</body>
</html>
